/*
 *  Created by SharpDevelop (To change this template use Tools | Options | Coding | Edit Standard Headers).
 * User: Jake Gustafson (Owner)
 * Date: 6/12/2006
 * Time: 6:21 AM
 * Uses some modified code from CodeProject.com
 * Uses info from "The Sonic Spot" : Guide : File Formats : Wave Files
 *
 * Terms:
 * Frame: a complete multichannel audio sample
 * SamplesPerSecond: is actually the Frames per second
 * BitsPerSample: refers to bits per [channel of a] Sample (not frames)
 *
 * Notes:
 * The Format Chunk: may not be the first chunk!
 * Wave is always Little endian (Wave was developed by Microsoft & IBM)
 *
 * Chunk IDs:
 * "fmt " : format
 * "fact"
 * "data" : wave data
 * "cue "
 * "plst"
 * "list"
 * "labl"
 * "ltxt"
 * "note"
 * "smpl"
 * "inst"
 * 
 * Fixing deviant files (from "The Sonic Spot" : Guide : File Formats : Wave Files):
    AvgBytesPerSec = SampleRate * BlockAlign
    BlockAlign = SignificantBitsPerSample / 8 * NumChannels
    ChunkDataSize = 4 + (NumCuePoints * 24)
 # Incorrect Block Alignment value - this can be dealt with by calculating the Block Alignment with the formula mentioned above.
 # Incorrect Average Samples Per Second value - this can be dealt with by calculating the Average Samples Per Second with the formula mentioned above.
 # Missing word alignment padding - this can be difficult to deal with, but can be done by giving the user a warning when unrecognized chunk ID's are encountered where a one byte read offset produces a recognized chunk ID. This is not a concrete solution, but will usually work even if the program doesn't have a comprehensive list of legal IDs. 
 
 
 CuePoint:
	 ID
	Each cue point has a unique identification value used to associate cue points
	with information in other chunks. For example, a Label chunk contains text that
	describes a point in the wave file by referencing the associated cue point.
	
	Position
	The position specifies the sample offset associated with the cue point in terms
	of the sample's position in the final stream of samples generated by the play
	list. Said in another way, if a play list chunk is specified, the position
	value is equal to the sample number at which this cue point will occur during
	playback of the entire play list as defined by the play list's order. If no play
	list chunk is specified this value should be 0.
	
	Data Chunk ID
	This value specifies the four byte ID used by the chunk containing the sample
	that corresponds to this cue point. A Wave file with no play list is always
	"data". A Wave file with a play list containing both sample data and silence
	may be either "data" or "slnt".
	
	Chunk Start
	The Chunk Start value specifies the byte offset into the Wave List Chunk of the
	chunk containing the sample that corresponds to this cue point. This is the same
	chunk described by the Data Chunk ID value. If no Wave List Chunk exists in the
	Wave file, this value is 0. If a Wave List Chunk exists, this is the offset into
	the "wavl" chunk. The first chunk in the Wave List Chunk would be specified with
	a value of 0.
	
	Block Start
	The Block Start value specifies the byte offset into the "data" or "slnt" Chunk
	to the start of the block containing the sample. The start of a block is defined
	as the first byte in uncompressed PCM wave data or the last byte in compressed
	wave data where decompression can begin to find the value of the corresponding
	sample value.
	
	Sample Offset
	The Sample Offset specifies an offset into the block (specified by Block Start)
	for the sample that corresponds to the cue point. In uncompressed PCM waveform
	data, this is simply the byte offset into the "data" chunk. In compressed
	waveform data, this value is equal to the number of samples (may or may not be
	bytes) from the Block Start to the sample that corresponds to the cue point.
	
	-The Sonic Spot
 */
//TODO: exception handling
using System;

namespace ExpertMultimedia {
	/// <summary>
	/// 24-byte Cue point for wave file
	/// </summary>
	public class CuePoint {
		uint dwId; //unique identification value
		uint dwPosition; //play-order position
		uint dwDataChunkID; //RIFF ID of corresponding data chunk
		uint dwChunkStart; //Byte Offset of Data Chunk
		uint dwBlockStart; //Byte Offset to sample of First Channel
		uint dwSampleOffset; //Byte Offset to sample byte of First Channel
		
		private static uint dwIdNow=0;
		public static uint MakeId() {
			return dwIdNow++;
		}
		public CuePoint() {
			dwId=MakeId();
			dwPosition=0;
			dwDataChunkID=0;
			dwChunkStart=0;
			dwBlockStart=0;
			dwSampleOffset=0;
		}
	}
	
	///<summary>
	///
	/// 12-byte Segment for wave file, stored in Plst
	///
	/// Cue Point ID
	/// The Cue Point ID specifies the starting sample for this segment by providing
	/// the value of a Cue Point defined in the Cue Point List. The ID that
	/// associates this segment with a Cue Point must be unique to all other segment
	/// Cue Point IDs.
	///
	/// Length
	/// The Segment Length specifies the number of samples to play/loop from the
	/// starting sample defined by the associated Cue Point.
	///
	/// Number of Repeats
	/// The number of repeats determines how many times this segment should be
	/// looped before playback should continue onto the next segment.
	///
	///</summary>
	public class Segment {
		public uint dwId;
		public uint dwSamples;
		public uint dwRepeats;
		
		private static uint dwIdNow=0;
		public static uint MakeId() {
			return dwIdNow++;
		}
		public Segment() {
			dwId=MakeId();
			dwSamples=0;
			dwRepeats=0;
		}
	}
	/// <summary>
	/// Wave manager for Wave files
	/// </summary>
	public class Wave { //streamable
		//public static UInt32 bitsAttrib;
		public int iChunks;
		public int iChunkArr; //if != iSize, then it's a stream
		public WaveChunk chunkRiff;
		public WaveChunk chunkFormat;
		public WaveChunk chunkFact;
		public WaveChunk chunkCue;
		public WaveChunk[] chunkarr;
		public const int SampleDepthByte8 = 8;
		public const int SampleDepthUshort16 = 16;
		public const int SampleDepthDVD24 = 24;
		public const int SampleDepthFloat32 = 32;
		public const ushort CompressUnknown = 0;
		public const ushort CompressPCMUncompressed = 1;
		public const ushort CompressMicrosoftADPCM = 2;
		public const ushort CompressITU_G711alaw = 6;
		public const ushort CompressITU_G711ulaw = 7; //actually 'mew' not 'u'
		public const ushort CompressIMA_ADPCM = 17;
		public const ushort CompressITU_G723ADPCM_Yamaha = 20;
		public const ushort CompressGSM_610 = 49;
		public const ushort CompressITU_G721_ADPCM = 64;
		public const ushort CompressMPEG = 80;
		public const ushort CompressExperimental = 0xFFFF;
		public static string CompressionTypeToString(uint wType) {
			string sReturn;
			if (wType==0) sReturn="Unknown";
			else if (wType==1) sReturn="PCM/uncompressed";
			else if (wType==2) sReturn="Microsoft ADPCM";
			else if (wType==6) sReturn="ITU G.711 a-law";
			else if (wType==7) sReturn="ITU G.711 "+char.ToString((char)230)+"-law";//"ITU G.711 ï¿½-law"; //TODO: see if this mew is displayed by retroengine
			else if (wType==17) sReturn="IMA ADPCM";
			else if (wType==20) sReturn="ITU G.723 ADPCM (Yamaha)";
			else if (wType==49) sReturn="GSM 6.10";
			else if (wType==64) sReturn="ITU G.721 ADPCM";
			else if (wType==80) sReturn="MPEG";
			else if (wType==65535) sReturn="Experimental";
			else sReturn="Unspecified Compression Type#"+wType.ToString();
			return sReturn;	
		}
	}
	public class Sound {
		Wave wave;
		//Flac flac; //here
	}
	//public class ChunkWave {
	//}
	public class WaveChunk {
		WaveChunk[] chunkarrSub; //ALL of the other chunks are a subchunk of the RIFF chunk
		//Format Chunk (26 bytes)
		public string sID; //Four bytes: "fmt "
		public uint dwSize; //Length in bytes from next byte including ALL bytes after wExtra ushort
		//TODO: if dwSize is odd, read the additional padding byte!
		//TODO: if dwSize is odd, write the additional padding byte!
		public ushort wCompression; //1 if uncompressed Microsoft PCM audio
		public ushort wChannels; //Number of channels
		public uint dwSamplesPerSec; //Frequency of the audio in Hz
		public uint dwAvgBytesPerSec;//For estimating RAM allocation
		public ushort wBlockAlign; //Sample frame size in bytes
		public ushort wSigBitsPerSample; //Significant bits per sample 2-65535
		//TODO: the following doesn't exist if dwSize is only 16!  Also, it may be zero!
		public ushort wExtra; //number extra format bytes following (should be at offset 24 since ChunkID)
		public byte[] byarrExtra;
		//Fact Chunk:
		//public string sID;            //Four bytes: "fact"
		//public uint   dwSize;         //Length of chunk
		public uint dwSamples;        //Number of audio frames

		//RIFF Chunk (all others are subchunks of RIFF chunk):
		//public string sID;            //Four bytes: "fact"
		//public uint dwSize;         //Length of chunk
		public string sRiffType="";//"WAVE", unless RIFF chunk, then ""

		//Silent Chunk 
		//public string sID;            //Four bytes: "slnt"
		//public uint dwSize;         //Length always = 4
		public uint dwSilentSamples;

		//Cue Chunk
		//public string sID;		//Four bytes: "cue "
		//public uint dwSize;		//Length = 4 + iCuePoints*24
		public uint dwCuePoints;	//Count of cue points
		public CuePoint[] cuepointarr;	//array of cue points

		//Playlist Chunk 
		//public string sID;		//Four bytes: "plst"
		//public uint dwSize;		//4+dwSegments*12 (The Sonic Spot says dwSegments*12)
		public uint dwSegments;		//count of segments
		public Segment[] segmentarr;	//array of segments
		
		//Data Chunk:
		//public string  sID;       //Four bytes: "data"
		//public uint    dwSize;    //Length of header in bytes
		//Different arrays for the different frame sizess
		public byte[] byarrData; //TODO: If odd#, MUST have padding zero-byte if odd length!  Whole file must be word-aligned.
		public short[] warrData;
		public uint[] dwarrData;
		public float[] farrData;
		/// <summary>
		/// </summary>
		public static WaveChunk MakeRIFF(uint dwFileSizeMinus8) {
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="RIFF";
			chunkNew.dwSize=dwFileSizeMinus8;
			//chunkNew.sRiffType="WAVE";
			return chunkNew;
		}
		//TODO: change all of this to byter calls
		/// <summary>
		/// </summary>
		public static WaveChunk MakeFMT(uint dwSize) {
			if (dwSize<16) dwSize=16;// dwSize Is 16 Or Else More If Has Extra
			if (dwSize>0xFFFF+18) dwSize=0xFFFF+18;//TODO: fix this??
			if (dwSize%2==1) dwSize++;//add padding for required word-alignment
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="fmt ";
			chunkNew.dwSize=dwSize;
			if (dwSize>18) {
				chunkNew.wExtra=(ushort)(dwSize-18);
				chunkNew.byarrData=new byte[(int)chunkNew.wExtra];
			}
			else {
				chunkNew.wExtra=0;
				chunkNew.byarrExtra=null;
			}
			return chunkNew;
		}
		/// <summary>
		/// Only contains format-dependent data for compressed wave files.
		/// NOT required unless Wave file is compressed.
		/// </summary>
		public static WaveChunk MakeFACT(uint dwSize, uint dwSamples) {
		/*
		 * A fact chunk stores compression code dependant information 
		 * about the contents of the Wave file. It is required by all
		 * compressed WAVE formats and if the waveform data is contained
		 * inside a "wavl" LIST chunk, but is not required for the
		 * uncompressed PCM WAVE format files (compression code 1) that
		 * contain the waveform data inside a "data" chunk.
		 *
		 *                                               -The Sonic Spot
		 */
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="fact";
			chunkNew.dwSize=dwSize;
			return chunkNew;
		}
		/// <summary>
		///  A wave list chunk is used to specify several alternating "slnt" and "data" chunks.
		///  slnt stands for silent, and the slnt chunks are used to save space.
		/// </summary>
		public static WaveChunk MakeWAVL(int iChunks, uint[] dwSizes, bool bSilentChunkFirst) {
			if (iChunks==0) return null; //TODO: report error;
			if (dwSizes==null) return null; //TODO: report error;
			if (iChunks!=dwSizes.Length) return null; //TODO: report error
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="wavl";
			chunkNew.dwSize=0;//incremented below
			chunkNew.chunkarrSub=new WaveChunk[iChunks];
			
			while (iChunks<0) {
				if (bSilentChunkFirst) {
					//TODO: finish this - silent chunk
					bSilentChunkFirst=false;
				}
				else {
					//TODO: finish this - data chunk
					bSilentChunkFirst=true;
				}
				iChunks--;
			}
			return chunkNew;
		}

		/// <summary>
		/// </summary>
		public static WaveChunk MakeSLNT(uint dwSilentSamples) {
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="slnt";
			chunkNew.dwSize=4;
			chunkNew.dwSilentSamples=dwSilentSamples;
			return chunkNew;
		}
/*
		/// <summary>
		/// </summary>
		public static WaveChunk MakeCue(uint dwCuePoints) {
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="cue ";
			chunkNew.dwSize=4 + dwCuePoints*24;
			chunkNew.dwCuePoints=dwCuePoints;
			chunkNew.cuepointarr=new CuePoint[iCuePoints];
			return chunkNew;
		}
		///<summary>
		///Playlist Chunk - "plst"
		/// The playlist chunk specifies the play order of a series of cue
		/// points. The cue points are defined in the cue chunk, somewhere
		/// else in the file. A playlist consists of an array of segments,
		/// each containing information about what sample the segment
		/// should start playing from, how long the segment is (in samples)
		/// and how many times to repeat the segment before moving on to
		/// the next segment in the play order.
		///</summary>
		public static WaveChunk MakePLST(uint dwSegments) {
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="plst";
			chunkNew.dwSize=4+dwSegments*12;//TODO: The Sonic Spot says dwSegments*12
			segmentarr=new Segment[dwSegments];
			return chunkNew;
		}
		
		//TODO: FINISH THIS - start at Associated Data List Chunk - "list"


		/// <summary>
		/// </summary>
		public static WaveChunk MakeDATA(uint dwSamples, int iSampleDepthBits) {
			WaveChunk chunkNew=new WaveChunk();
			chunkNew.sID="data";
			bool bDone=false;
			int iSigBytesPerSample;
			while (!bDone) {
				if (iSampleDepthBits==8) {
					chunkNew.wSigBitsPerSample=iSampleDepthBits;
					iSigBytesPerSample=iSampleBits/8;
					byarrData=new byte[dwSamples];
					bDone=true;
				}
				else if (iSampleDepthBits=16) {
					chunkNew.wSigBitsPerSample=iSampleDepthBits;
					iSigBytesPerSample=iSampleBits/8;
					warrData=new ushort[dwSamples];
					bDone=true;
				}
				else if (iSampleDepthBits=24) {
					chunkNew.wSigBitsPerSample=iSampleDepthBits;
					iSigBytesPerSample=iSampleBits/8;
					dwarrData=new uint[dwSamples];
					bDone=true;
				}
				else if (iSampleDepthBits=32) {
					chunkNew.wSigBitsPerSample=iSampleDepthBits;
					iSigBytesPerSample=iSampleBits/8;
					farrData=new float[dwSamples];
					bDone=true;
				}
				else {
					iSampleDepthBits=16;
					//TODO: return error
				}
			}
			chunkNew.dwSize=dwSamples*iSigBytesPerSample;
			return chunkNew;
		}
		*/
	}//end class WaveChunk 
}//end namespace
